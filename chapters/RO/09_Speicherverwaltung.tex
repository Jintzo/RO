\section{Virtuelle Speicherverwaltung}

\textbf{Notwendigkeit}
\begin{items}
  \item Immer größere Programme
  \item Immer mehr Programme "`gleichzeitig"'
  \item \( \leadsto \) verfügbarer Arbeitsspeicher schnell zu klein
  \item \underline{Lösung}: Nur gerade benötigte Teile der aktiven Programme im Arbeitsspeicher, Rest bei Bedarf aus Hintergrundspeicher nachladen (\emph{swapping}, \emph{paging})
  \item \underline{Umsetzung}: \textbf{MMU} (\emph{memory management unit}) setzt virtuelle Adressen in physikalische um
\end{items}

\textbf{Virtueller Speicher}
\begin{items}
  \item Speicherkapazität größer als effektive Hauptspeicherkapazität
  \item Betriebssystem lagert nach Bedarf Speicherbereiche ein/aus
  \item MMU-Adressberechnung hardwaremäßig eindeutig
  \item Abbildungsinformation in Übersetzungstabellen gespeichert
  \item \( \leadsto \) Abbildungsinformation für zusammenhängende Adressbereiche, um Übersetzungstabellen klein zu halten
\end{items}

\textbf{Virtueller Speicher -- Verwaltung (Segmentierung)}
\begin{items}
  \item Virtueller Adressraum wird in Segmente verschiedener Länge zerteilt
  \item Mehrere Segmente pro Programm (zB für Programmcode, Daten)
  \item Segmente enthalten logisch zusammenhängende Informationen, relativ groß
  \item \underline{Vorteile}: \\*
    - spiegelt logische Programmstruktur wieder \\*
    - große Segmente \( \leadsto \) relativ seltener Datentransfer
  \item \underline{Nachteile}: \\*
    - Datentransfer umfangreich falls notwendig \\*
    - Programm aus nur einem Code- und Datensegment \\* \phantom{-} \( \leadsto \) muss vollständig eingelagert werden
\end{items}

\textbf{Virtueller Speicher -- Verwaltung (Seiten)}
\begin{items}
  \item logischer und physikalischer Adressraum in Teile fester länge (Pages) zerteilt
  \item Pages relativ klein (256-4k Byte)
  \item Viele Seiten pro Prozess, keine logischen Zusammenhänge
  \item \underline{Vorteile}: \\*
    - kleine Seiten \( \leadsto \) nur wirklich benötigter \\* \phantom{-} Programmteil wird eingelagert \\*
    - geringerer Verwaltungsaufwand als Segmentierung
  \item \underline{Nachteile}: \\*
    - häufigerer Datentransfer als bei Segmentierung
\end{items}

\textbf{Segmentbasierte Speicherverwaltung -- Implementierung}
\begin{items}
  \item virtuelle Adresse wird in \textbf{Segmentnummer} (\( n \) höherwertigste Bits der virtuellen Adresse) als Segmentkennung und in \textbf{Bytenummer} (verbleibende \( m \) Bits der virtuellen Adresse) als Abstand zum Segmentanfang unterteilt
  \item max. virtuelle Segmentanzahl \( 2^n \), max. Segmentgröße \( 2^m \)
  \item Adressabbilung über Segmenttabelle (im MMU-Registerspeicher)
  \item reale Adresse = Segmentbasisadresse + virtuelle Byte-Nummer
  \item Segmentlängenangaben um segmentüberschreitende Zugriffe feststellen/verhindern zu können
  \item Verschnitt: ungenutzter Raum bei Segmenten kleiner als \( 2^m \)
  \item \( \leadsto \) gute Hauptspeicherausnutzung, wenn Segmentgrenzen an jeder Byteadresse zulässig sind
  \item Realität: Segmentgrenzen an Vielfachen von Blöcken (hier 256 Bytes)
  \item Segmente im virtuellen physikalischen Adressraum in 256-Byte-Blöcke unterteilt
  \item \( \leadsto \) \( m \)-Bit-Bytenummer wird aufgeteilt in kürzere Bytenummer für Byteadressierung in Block und Blocknummer
  \item Adressumsetzung: virtuelle Segmentnummer wird auf reale 24-Bit-Blocknummer als Segmentbasis abgebildet
  \item Virtuelle Bytenummer für Adressierung innerhalb des Blocks wird unverändert übernommen
\end{items}

\newpage

\textbf{Virtuelle Speicherverwaltung -- Probleme}
\begin{items}
  \item \underline{Einlagerungszeitpunkt}: Wann werden Segmente/Seiten in Hauptspeicher eingelagert?
  \item \underline{Zuweisungsproblem}: Wo in Hauptspeicher werden Seiten/Segmente eingelagert?
  \item \underline{Ersetzungsproblem}: Welche Segmente/Seiten auslagern um Platz für neu benötigte Daten zu schaffen?
\end{items}

\textbf{Probleme -- Einlagerungszeitpunkt}
\begin{items}
  \item \underline{Gängiges Verwahren}: Einlagerung auf Anforderung (\emph{demand paging} bei Seitenverfahren)
  \item Daten werden eingelagert, sobald auf sie zugegriffen wird, aber nicht in Hauptspeicher liegen
  \item \underline{Segment-/Seitenfehler} (\emph{segment/page fault}): Zugriff auf nicht in Hauptspeicher vorhandene(s) Segment/Seite
\end{items}

\textbf{Probleme -- Zuweisungsproblem (Segmentierung)}
\begin{items}
  \item ausreichend große Lücke in Hauptspeicher muss gefunden werden
  \item Strategien:
  \begin{enumeration}
    \item \textbf{first-fit}: erste passende Lücke wird genommen
    \item \textbf{best-fit}: kleinste passende Lücke wird genommen
    \item \textbf{worst-fit}: größte passende Lücke wird genommen
  \end{enumeration}
  \item \underline{Problem}: Speicher zerfällt in belegte und unbelegte Speicherbereiche \\*
    \( \leadsto \) \textbf{externe Fragmentierung}
  \item unbelegte Speicherbereiche oft zu klein um weitere Segmente aufnehmen zu können
\end{items}

\textbf{Probleme -- Zuweisungsproblem (Seiten)}
\begin{items}
  \item Problem taucht nicht auf, da alle Seiten gleich groß \\*
    \( \leadsto \) es entstehen immer passende Lücken \\*
    \( \leadsto \) \textbf{keine externe Fragmentierung}
  \item \underline{Interne Fragmentierung}: Einheitliche Seitengröße \( \leadsto \) auf letzter Seite des Programm-Moduls wahrscheinlich ungenutzter Leerraum
\end{items}

\textbf{Probleme -- Ersetzungsproblem (Segmentierung)}
\begin{items}
  \item Limitierung der Anzahl gleichzeitig von einem Prozess benutzbaren Segmente
  \item \( \leadsto \) bei Einlagerung eines neuen Segments wird anderes Segment des Prozesses ausgelagert
\end{items}

\textbf{Probleme -- Ersetzungsproblem (Seiten)}
\begin{items}
  \item Seitenersetzungsstrategien:
  \begin{enumeration}
    \item \textbf{FIFO} (\emph{first in first out}): älteste Seite wird ersetzt
    \item \textbf{LIFO} (\emph{last in first out}): jüngste Seite wird ersetzt
    \item \textbf{LRU} (\emph{last recently used}): am längsten unbenutzte Seite wird ersetzt
    \item \textbf{LFU} (\emph{least frequently used}): am seltensten benutzte Seite wird ersetzt
    \item \textbf{LRD} (\emph{least reference density}): Seite mit geringster Zugriffsdichte wird ersetzt
  \end{enumeration}
\end{items}

\textbf{Virtueller vs. physikalischer Cache}
\begin{items}
  \item \underline{virtueller Cache}: zwischen CPU und MMU, Tags = höherwertigste Bits der logischen Adressen
  \item Vorteile: \\*
    - bei Treffer keine MMU nötig
  \item \underline{physikalischer Cache}: zwischen MMU und Speicher, Tags = höherwertigste Bits der physikalischen Adressen
  \item Vorteile: \\*
    - kleinerer Tag, da physikalische Adresse idR viel kleiner als \\* \phantom{-} logische Adresse ist \\*
\end{items}

\newpage

\textbf{Segmentorientierte Speicherverwaltung -- Beispiel x86}
\begin{items}
  \item \underline{Segment-Deskriptor}: beschreibt sein Segment durch Attribute: \\*
    - \textbf{Segment-Basisadresse} (\emph{base address}) \\*
    - \textbf{Segment-Größe} (\emph{limit}) in Bytes \\*
    - \textbf{Zugriffsrechte} (\emph{access rights}) auf das Segment
  \item Speicherwort wird durch \textbf{Segment-Selektor} (kennzeichnet Segmentanfang) und \textbf{Offset} innerhalb des Segments adressiert
  \item Segment-Selektoren wechseln selten, da durch Lokalitätseigenschaften von Programmen nicht bei jedem Hauptspeicherzugriff neues Segment benutzt wird
  \item Segment-Selektoren in \textbf{Segment-Registern} gespeichert (wegen Geschwindigkeit)
  \item Segment-Register: \\*
    - \textbf{Code-Segment} (\code{CS}) \\*
    - \textbf{Stack-Segment} (\code{SS}) \\*
    - \textbf{Daten-Segment} (\code{DS}) \\*
    - \textbf{Extra-Segment} (\code{ES}, \code{FS}, \code{GS},...) \\*
    \( \leadsto \) Speicherwortadressierung durch Segment-Register + Offset
  \item Segment-Deskriptor-Cache: Speichert wichtige Informationen über ausgewähltes Segment \\*
    \( \leadsto \) keine Speicherzugriffe beim Lesen von Segmenteigenschaften
  \item Jedes Segment mit Anfangsadresse im Segmentregister ist physikalisch im Hauptspeicher
  \item \textbf{Arbeitsmenge} (\emph{working set}): durch Segmentregister spezifizierte Segmente eines Prozesses
\end{items}

\textbf{Adressierungsmodi -- Beispiel x86}
\begin{items}
  \item Verschiedene Adressierungsmodi möglich (für Kompatibilität)
  \item \underline{Real (Address) Mode} (Kompatibilitätsmode zu 8086): \\*
    - physikalische Adressen: 20 Bit \\*
    - max. adressierbare Hauptspeicherkapazität: 1 MB \\*
    - max. Segmentlänge: 64 KB \\*
    - Abbildung virtueller Adressraum (mehrere TB) auf \\* \phantom{-} physikalischen Adressraum (4 GB)
\end{items}